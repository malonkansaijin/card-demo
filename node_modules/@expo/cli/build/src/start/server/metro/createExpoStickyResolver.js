"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    _dependenciesToRegex: function() {
        return _dependenciesToRegex;
    },
    createStickyModuleResolver: function() {
        return createStickyModuleResolver;
    },
    createStickyModuleResolverInput: function() {
        return createStickyModuleResolverInput;
    }
});
const debug = require('debug')('expo:start:server:metro:sticky-resolver');
const AUTOLINKING_PLATFORMS = [
    'android',
    'ios',
    'web'
];
const escapeDependencyName = (dependency)=>dependency.replace(/[*.?()[\]]/g, (x)=>`\\${x}`);
const _dependenciesToRegex = (dependencies)=>new RegExp(`^(${dependencies.map(escapeDependencyName).join('|')})($|/.*)`);
/** Creates a function to load a dependency of the `expo` package */ const createExpoDependencyLoader = (request)=>{
    let mod;
    return ()=>{
        if (!mod) {
            const expoPath = require.resolve('expo/package.json');
            const autolinkingPath = require.resolve(request, {
                paths: [
                    expoPath
                ]
            });
            return mod = require(autolinkingPath);
        }
        return mod;
    };
};
const getAutolinkingModule = createExpoDependencyLoader('expo-modules-autolinking/exports');
const getReactNativeConfigModule = createExpoDependencyLoader('expo-modules-autolinking/build/reactNativeConfig');
const getAutolinkingOptions = async (projectRoot, platform)=>{
    const autolinking = getAutolinkingModule();
    return await autolinking.mergeLinkingOptionsAsync({
        searchPaths: [],
        projectRoot,
        platform: platform === 'ios' ? 'apple' : platform,
        onlyProjectDeps: true,
        silent: true
    });
};
const getAutolinkingResolutions = async (opts)=>{
    const autolinking = getAutolinkingModule();
    const resolvedModules = await autolinking.findModulesAsync(opts);
    return Object.fromEntries(Object.entries(resolvedModules).map(([key, entry])=>[
            key,
            entry.path
        ]));
};
const getReactNativeConfigResolutions = async (opts)=>{
    const reactNativeConfigModule = getReactNativeConfigModule();
    const configResult = await reactNativeConfigModule.createReactNativeConfigAsync({
        ...opts,
        // NOTE(@kitten): web will use ios here. This is desired since this function only accepts android|ios.
        // However, we'd still like to sticky resolve dependencies for web
        platform: opts.platform === 'android' ? 'android' : 'ios',
        // TODO(@kitten): Unclear if this should be populated or directly relates to sticky resolution
        transitiveLinkingDependencies: []
    });
    return Object.fromEntries(Object.entries(configResult.dependencies).map(([key, entry])=>[
            key,
            entry.root
        ]));
};
const getPlatformModuleDescription = async (projectRoot, platform)=>{
    const searchOptions = await getAutolinkingOptions(projectRoot, platform);
    const autolinkingResolutions$ = getAutolinkingResolutions(searchOptions);
    const reactNativeConfigResolutions$ = getReactNativeConfigResolutions(searchOptions);
    const resolvedModulePaths = {
        ...await reactNativeConfigResolutions$,
        ...await autolinkingResolutions$
    };
    const resolvedModuleNames = Object.keys(resolvedModulePaths);
    debug(`Sticky resolution for ${platform} registered ${resolvedModuleNames.length} resolutions:`, resolvedModuleNames);
    return {
        platform,
        moduleTestRe: _dependenciesToRegex(resolvedModuleNames),
        resolvedModulePaths
    };
};
async function createStickyModuleResolverInput({ platforms, projectRoot }) {
    return Object.fromEntries(await Promise.all(platforms.filter((platform)=>AUTOLINKING_PLATFORMS.includes(platform)).map(async (platform)=>{
        const platformModuleDescription = await getPlatformModuleDescription(projectRoot, platform);
        return [
            platformModuleDescription.platform,
            platformModuleDescription
        ];
    })));
}
function createStickyModuleResolver(input, { getStrictResolver }) {
    if (!input) {
        return undefined;
    }
    const fileSpecifierRe = /^[\\/]|^\.\.?(?:$|[\\/])/i;
    const isAutolinkingPlatform = (platform)=>!!platform && input[platform] != null;
    return function requestStickyModule(immutableContext, moduleName, platform) {
        if (!isAutolinkingPlatform(platform)) {
            return null;
        } else if (fileSpecifierRe.test(moduleName)) {
            return null;
        }
        const moduleDescription = input[platform];
        const moduleMatch = moduleDescription.moduleTestRe.exec(moduleName);
        if (moduleMatch) {
            const resolvedModulePath = moduleDescription.resolvedModulePaths[moduleMatch[1]] || moduleName;
            // We instead resolve as if it was a dependency from within the module (self-require/import)
            const context = {
                ...immutableContext,
                nodeModulesPaths: [
                    resolvedModulePath
                ],
                originModulePath: resolvedModulePath
            };
            const res = getStrictResolver(context, platform)(moduleName);
            debug(`Sticky resolution for ${platform}: ${moduleName} -> ${resolvedModulePath}`);
            return res;
        }
        return null;
    };
}

//# sourceMappingURL=createExpoStickyResolver.js.map
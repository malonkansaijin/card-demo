{"version":3,"sources":["../../../../../src/start/server/metro/withMetroResolvers.ts"],"sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ConfigT as MetroConfig } from '@expo/metro/metro-config';\nimport type {\n  ResolutionContext,\n  CustomResolutionContext,\n  CustomResolver,\n} from '@expo/metro/metro-resolver';\nimport { resolve as metroResolver } from '@expo/metro/metro-resolver';\nimport chalk from 'chalk';\nimport path from 'path';\n\nimport { isFailedToResolveNameError, isFailedToResolvePathError } from './metroErrors';\nimport { env } from '../../../utils/env';\n\nconst debug = require('debug')('expo:metro:withMetroResolvers') as typeof console.log;\n\nexport type { CustomResolver as MetroResolver };\n\n/** Expo Metro Resolvers can return `null` to skip without throwing an error. Metro Resolvers will throw either a `FailedToResolveNameError` or `FailedToResolvePathError`. */\nexport type ExpoCustomMetroResolver = (\n  ...args: Parameters<CustomResolver>\n) => ReturnType<CustomResolver> | null;\n\n/** @returns `MetroResolver` utilizing the upstream `resolve` method. */\nexport function getDefaultMetroResolver(projectRoot: string): CustomResolver {\n  return (context: ResolutionContext, moduleName: string, platform: string | null) => {\n    return metroResolver(context, moduleName, platform);\n  };\n}\n\nfunction optionsKeyForContext(context: ResolutionContext) {\n  const canonicalize: typeof import('@expo/metro/metro-core/canonicalize').default = require('@expo/metro/metro-core/canonicalize');\n  // Compound key for the resolver cache\n  return JSON.stringify(context.customResolverOptions ?? {}, canonicalize) ?? '';\n}\n\n/**\n * Extend the Metro config `resolver.resolveRequest` method with additional resolvers that can\n * exit early by returning a `Resolution` or skip to the next resolver by returning `null`.\n *\n * @param config Metro config.\n * @param resolvers custom MetroResolver to chain.\n * @returns a new `MetroConfig` with the `resolver.resolveRequest` method chained.\n */\nexport function withMetroResolvers(\n  config: MetroConfig,\n  inputResolvers: (ExpoCustomMetroResolver | undefined)[]\n): MetroConfig {\n  const resolvers = inputResolvers.filter((x) => x != null);\n  debug(\n    `Appending ${\n      resolvers.length\n    } custom resolvers to Metro config. (has custom resolver: ${!!config.resolver?.resolveRequest})`\n  );\n  // const hasUserDefinedResolver = !!config.resolver?.resolveRequest;\n  // const defaultResolveRequest = getDefaultMetroResolver(projectRoot);\n  const originalResolveRequest = config.resolver?.resolveRequest;\n\n  return {\n    ...config,\n    resolver: {\n      ...config.resolver,\n      resolveRequest(context, moduleName, platform) {\n        const upstreamResolveRequest = context.resolveRequest;\n\n        const universalContext = {\n          ...context,\n          resolveRequest(\n            ctx: CustomResolutionContext,\n            moduleName: string,\n            platform: string | null\n          ) {\n            for (const resolver of resolvers) {\n              try {\n                const res = resolver(ctx, moduleName, platform);\n                if (res) {\n                  return res;\n                }\n              } catch (error: any) {\n                // If the error is directly related to a resolver not being able to resolve a module, then\n                // we can ignore the error and try the next resolver. Otherwise, we should throw the error.\n                const isResolutionError =\n                  isFailedToResolveNameError(error) || isFailedToResolvePathError(error);\n                if (!isResolutionError) {\n                  throw error;\n                }\n                debug(\n                  `Custom resolver (${resolver.name || '<anonymous>'}) threw: ${error.constructor.name}. (module: ${moduleName}, platform: ${platform}, env: ${ctx.customResolverOptions?.environment}, origin: ${ctx.originModulePath})`\n                );\n              }\n            }\n            // If we haven't returned by now, use the original resolver or upstream resolver.\n            return upstreamResolveRequest(ctx, moduleName, platform);\n          },\n        };\n\n        // If the user defined a resolver, run it first and depend on the documented\n        // chaining logic: https://facebook.github.io/metro/docs/resolution/#resolution-algorithm\n        //\n        // config.resolver.resolveRequest = (context, moduleName, platform) => {\n        //\n        //  // Do work...\n        //\n        //  return context.resolveRequest(context, moduleName, platform);\n        // };\n        const firstResolver = originalResolveRequest ?? universalContext.resolveRequest;\n        return firstResolver(universalContext, moduleName, platform);\n      },\n    },\n  };\n}\n\n/**\n * Hook into the Metro resolver chain and mutate the context so users can resolve against our custom assumptions.\n * For example, this will set `preferNativePlatform` to false when bundling for web.\n * */\nexport function withMetroMutatedResolverContext(\n  config: MetroConfig,\n  getContext: (\n    ctx: CustomResolutionContext,\n    moduleName: string,\n    platform: string | null\n  ) => CustomResolutionContext\n): MetroConfig {\n  const defaultResolveRequest = getDefaultMetroResolver(config.projectRoot);\n  const originalResolveRequest = config.resolver?.resolveRequest;\n\n  return {\n    ...config,\n    resolver: {\n      ...config.resolver,\n      resolveRequest(context, moduleName, platform) {\n        const universalContext = getContext(context, moduleName, platform);\n        const firstResolver =\n          originalResolveRequest ?? universalContext.resolveRequest ?? defaultResolveRequest;\n        return firstResolver(universalContext, moduleName, platform);\n      },\n    },\n  };\n}\n\nexport function withMetroErrorReportingResolver(config: MetroConfig): MetroConfig {\n  if (!env.EXPO_METRO_UNSTABLE_ERRORS) {\n    return config;\n  }\n\n  const originalResolveRequest = config.resolver?.resolveRequest;\n\n  function mutateResolutionError(\n    error: Error,\n    context: ResolutionContext,\n    moduleName: string,\n    platform: string | null\n  ) {\n    const inputPlatform = platform ?? 'null';\n\n    const mapByOrigin = depGraph.get(optionsKeyForContext(context));\n    const mapByPlatform = mapByOrigin?.get(inputPlatform);\n\n    if (!mapByPlatform) {\n      return error;\n    }\n\n    // collect all references inversely using some expensive lookup\n\n    const getReferences = (origin: string) => {\n      const inverseOrigin: { origin: string; previous: string; request: string }[] = [];\n\n      if (!mapByPlatform) {\n        return inverseOrigin;\n      }\n\n      for (const [originKey, mapByTarget] of mapByPlatform) {\n        // search comparing origin to path\n\n        const found = [...mapByTarget.values()].find((resolution) => resolution.path === origin);\n        if (found) {\n          inverseOrigin.push({\n            origin,\n            previous: originKey,\n            request: found.request,\n          });\n        }\n      }\n\n      return inverseOrigin;\n    };\n\n    const pad = (num: number) => {\n      return new Array(num).fill(' ').join('');\n    };\n\n    const root = config.server?.unstable_serverRoot ?? config.projectRoot;\n\n    type InverseDepResult = {\n      origin: string;\n      request: string;\n      previous: InverseDepResult[];\n    };\n    const recurseBackWithLimit = (\n      req: { origin: string; request: string },\n      limit: number,\n      count: number = 0\n    ) => {\n      const results: InverseDepResult = {\n        origin: req.origin,\n        request: req.request,\n        previous: [],\n      };\n\n      if (count >= limit) {\n        return results;\n      }\n\n      const inverse = getReferences(req.origin);\n      for (const match of inverse) {\n        // Use more qualified name if possible\n        // results.origin = match.origin;\n        // Found entry point\n        if (req.origin === match.previous) {\n          continue;\n        }\n        results.previous.push(\n          recurseBackWithLimit({ origin: match.previous, request: match.request }, limit, count + 1)\n        );\n      }\n      return results;\n    };\n\n    const inverseTree = recurseBackWithLimit(\n      { origin: context.originModulePath, request: moduleName },\n      // TODO: Do we need to expose this?\n      35\n    );\n\n    if (inverseTree.previous.length > 0) {\n      debug('Found inverse graph:', JSON.stringify(inverseTree, null, 2));\n      let extraMessage = chalk.bold('Import stack:');\n      const printRecursive = (tree: InverseDepResult, depth: number = 0) => {\n        let filename = path.relative(root, tree.origin);\n        if (filename.match(/\\?ctx=[\\w\\d]+$/)) {\n          filename = filename.replace(/\\?ctx=[\\w\\d]+$/, chalk.dim(' (require.context)'));\n        } else {\n          let formattedRequest = chalk.green(`\"${tree.request}\"`);\n\n          if (\n            // If bundling for web and the import is pulling internals from outside of react-native\n            // then mark it as an invalid import.\n            inputPlatform === 'web' &&\n            !/^(node_modules\\/)?react-native\\//.test(filename) &&\n            tree.request.match(/^react-native\\/.*/)\n          ) {\n            formattedRequest =\n              formattedRequest +\n              chalk`\\n          {yellow Importing react-native internals is not supported on web.}`;\n          }\n\n          filename = filename + chalk`\\n{gray  |} {cyan import} ${formattedRequest}\\n`;\n        }\n        let line = '\\n' + pad(depth) + chalk.gray(' ') + filename;\n        if (filename.match(/node_modules/)) {\n          line = chalk.gray(\n            // Bold the node module name\n            line.replace(/node_modules\\/([^/]+)/, (_match, p1) => {\n              return 'node_modules/' + chalk.bold(p1);\n            })\n          );\n        }\n        extraMessage += line;\n        for (const child of tree.previous) {\n          printRecursive(\n            child,\n            // Only add depth if there are multiple children\n            tree.previous.length > 1 ? depth + 1 : depth\n          );\n        }\n      };\n      printRecursive(inverseTree);\n\n      debug('inverse graph message:', extraMessage);\n\n      // @ts-expect-error\n      error._expoImportStack = extraMessage;\n    } else {\n      debug('Found no inverse tree for:', context.originModulePath);\n    }\n\n    return error;\n  }\n\n  const depGraph: Map<\n    // custom options\n    string,\n    Map<\n      // platform\n      string,\n      Map<\n        // origin module name\n        string,\n        Set<{\n          // required module name\n          path: string;\n          // This isn't entirely accurate since a module can be imported multiple times in a file,\n          // and use different names. But it's good enough for now.\n          request: string;\n        }>\n      >\n    >\n  > = new Map();\n\n  return {\n    ...config,\n    resolver: {\n      ...config.resolver,\n      resolveRequest(context, moduleName, platform) {\n        const storeResult = (res: NonNullable<ReturnType<ExpoCustomMetroResolver>>) => {\n          const inputPlatform = platform ?? 'null';\n\n          const key = optionsKeyForContext(context);\n          if (!depGraph.has(key)) depGraph.set(key, new Map());\n          const mapByTarget = depGraph.get(key);\n          if (!mapByTarget!.has(inputPlatform)) mapByTarget!.set(inputPlatform, new Map());\n          const mapByPlatform = mapByTarget!.get(inputPlatform);\n          if (!mapByPlatform!.has(context.originModulePath))\n            mapByPlatform!.set(context.originModulePath, new Set());\n          const setForModule = mapByPlatform!.get(context.originModulePath)!;\n\n          const qualifiedModuleName = res?.type === 'sourceFile' ? res.filePath : moduleName;\n          setForModule.add({ path: qualifiedModuleName, request: moduleName });\n        };\n\n        // If the user defined a resolver, run it first and depend on the documented\n        // chaining logic: https://facebook.github.io/metro/docs/resolution/#resolution-algorithm\n        //\n        // config.resolver.resolveRequest = (context, moduleName, platform) => {\n        //\n        //  // Do work...\n        //\n        //  return context.resolveRequest(context, moduleName, platform);\n        // };\n        try {\n          const firstResolver = originalResolveRequest ?? context.resolveRequest;\n          const res = firstResolver(context, moduleName, platform);\n          storeResult(res);\n          return res;\n        } catch (error: any) {\n          throw mutateResolutionError(error, context, moduleName, platform);\n        }\n      },\n    },\n  };\n}\n"],"names":["getDefaultMetroResolver","withMetroErrorReportingResolver","withMetroMutatedResolverContext","withMetroResolvers","debug","require","projectRoot","context","moduleName","platform","metroResolver","optionsKeyForContext","canonicalize","JSON","stringify","customResolverOptions","config","inputResolvers","resolvers","filter","x","length","resolver","resolveRequest","originalResolveRequest","upstreamResolveRequest","universalContext","ctx","res","error","isResolutionError","isFailedToResolveNameError","isFailedToResolvePathError","name","constructor","environment","originModulePath","firstResolver","getContext","defaultResolveRequest","env","EXPO_METRO_UNSTABLE_ERRORS","mutateResolutionError","inputPlatform","mapByOrigin","depGraph","get","mapByPlatform","getReferences","origin","inverseOrigin","originKey","mapByTarget","found","values","find","resolution","path","push","previous","request","pad","num","Array","fill","join","root","server","unstable_serverRoot","recurseBackWithLimit","req","limit","count","results","inverse","match","inverseTree","extraMessage","chalk","bold","printRecursive","tree","depth","filename","relative","replace","dim","formattedRequest","green","test","line","gray","_match","p1","child","_expoImportStack","Map","storeResult","key","has","set","Set","setForModule","qualifiedModuleName","type","filePath","add"],"mappings":"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"}